# Gnome R Data Miner: GNOME interface to R for Data Mining
#
# Time-stamp: <2009-02-07 07:43:45 Graham Williams>
#
# Textview widget support
#
# Copyright (c) 2009 Togaware Pty Ltd
#
# This files is part of Rattle.
#
# Rattle is free software: you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# Rattle is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Rattle. If not, see <http://www.gnu.org/licenses/>.
#
# TODO
#
#	We are in the middle of migrating from using a string to
#	identify the widget, and assuming theWidget will get the
#	actual widget (which only works for the main rattleGUI window)
#	to passing the actual widget itself, which is much more
#	general. For now, allow both, through the use of getTextview.
#
#       071128 New version of R (since about 6.2.0) have a default
#       value for useFancyFonts that does not work with textviews in
#       RGtk2 (and probably other things in RGtk2). This affects only
#       MSWindows. A quick fix, which has been done for setTextview,
#       but not the rest yet, is to wrap textview displays with:
#
#         oldopt <- options(useFancyQuotes="utf8")
#         ...
#         options(oldopt)
#

getTextview <- function(tv)
{
  # From either a string or the actual object, return the textview
  # object. This is usful internally in this file whilst we migrate
  # to not using the string to name the textview, but passing the
  # object itself.
  
  wid <- FALSE
  if (inherits(tv, "GtkTextView"))
    wid <- tv
  else if (inherits(tv, "character"))
    wid <- theWidget(tv)
  return(wid)
}

resetTextview <- function(tv, ..., sep="", tvsep=TRUE)
{
  # We call this if we simply want to blank the textview, and
  # optionally, add new text to the textview. We use a default
  # separator of nothing, rather than a single space, since this
  # suits the usual list of strings being passed into the textview,
  # where I have a string introducing what follows, then there is the
  # output of some command. By default we also add a Rattle separator
  # line, as the usual usage of resetTexview will be to clear the
  # textview and add a message, in one go. There are times when we
  # don't want the separator though.
  
  if (is.null(wid <- getTextview(tv)))
  {
    errorDialog("E138: Should not be here.",
                "The textview object supplied to resetTextview",
                "is neither a GtkTextView nor a string.",
                "We found a", class(tv)[1], crv$support.msg)
    return(FALSE)
  }
  wid$modifyFont(pangoFontDescriptionFromString("monospace 10"))
  msg <- paste(sep=sep, ...)
  if (length(msg) > 0)
  {
    wid$getBuffer()$setText(msg)
    if (tvsep) appendTextview(tv)
  }
  else
    wid$getBuffer()$setText("")

}

appendTextview <- function(tv, ..., sep="", tvsep=TRUE)
{
  # Append a message to the given textview. Optionally add a Rattle
  # separator to the textview. By default, paste the strings of the
  # message together without a speartor.
  
  if (is.null(wid <- getTextview(tv)))
  {
    errorDialog("E140: Should not be here.",
                "The textview object supplied to appendTextview",
                "is neither a GtkTextView nor a string.",
                "We found a", class(tv)[1], crv$support.msg)
    return(FALSE)
  }
  msg <- paste(sep=sep, ...)
  if (tvsep) msg <- paste(msg, textviewSeparator(), sep="")
  buf <- wid$getBuffer()
  location <- buf$getEndIter()$iter
  buf$insert(location, msg)
}

textviewSeparator <- function()
{
  return(paste(sprintf("\n\nGenerated by %s %s %s\n", crv$appname, Sys.time(),
                       Sys.info()["user"]),
               paste(rep("=", 70), collapse=""), "\n", sep=""))
}

getTextviewContent <- function(TV)
{
  # Extract text contents of specified textview and return
  # it. Designed for use in saveProject.
  
  log.buf <- theWidget(TV)$getBuffer()
  start <- log.buf$getStartIter()$iter
  end <- log.buf$getEndIter()$iter
  return(log.buf$getText(start, end))
}

# STOP USING THE FOLLOWING

setTextview <- function(tv, ..., sep="")
{
  # Stop using this - use resetTextview instead

  if (is.null(wid <- getTextview(tv)))
  {
    errorDialog("E137: Should not be here.",
                "The textview object supplied to setTextview",
                "is neither a GtkTextView nor a string.",
                "We found a", class(tv)[1], crv$support.msg)
    return(FALSE)
  }
  oldopt <- options(useFancyQuotes="utf8") # Bug fix for MSWindows [071128]
  msg <- paste(sep=sep, ...)
  if (length(msg) == 0) msg <-""
  wid$getBuffer()$setText(msg)
  options(oldopt) # Bug fix for MSWindows [071128]
}

addTextview <- function(tv, ..., sep="")
{
  if (is.null(wid <- getTextview(tv)))
  {
    errorDialog("E139: Should not be here.",
                "The textview object supplied to addTextview",
                "is neither a GtkTextView nor a string.",
                "We found a", class(tv)[1], crv$support.msg)
    return(FALSE)
  }
  msg <- paste(sep=sep, ...)
  if (length(msg) == 0) msg <-""
  tv.buf <- wid$getBuffer()
  loc <- tv.buf$getEndIter()$iter
  tv.buf$insert(loc, msg)
}
  
setTextviewContents <- function(TV, text)
{
  # Set the text contents of the specified textview to the supplied
  # text. Designed for use in loadProject.

  resetTextview(TV)
  theWidget(TV)$setWrapMode("none")
  if (is.null(text))
    theWidget(TV)$getBuffer()$setText("")
  else
    theWidget(TV)$getBuffer()$setText(text)
}

resetTextviews <- function()
{
  # 090202 Reset all text views to default content, as when Rattle
  # starts up or the user has selected New Project, or has loaded a
  # new dataset.
  
  resetTextview("summary_textview", "UNIVARIATE DATASET SUMMARY

It is useful to understand how our data is distributed

The summary here will include more details depending on
which check buttons you choose. 

The Summary option provides a very brief summary.

The Describe option provides comprehensive summaries of each variable.

Kurtosis and Skewness allow these measure to be compared across
the available numeric variables.", tvsep=FALSE)

  resetTextview("playwith_textview", "LATTICIST DATA VISUALISER

Latticist provides a graphical user interface for exploratory data visualisation. 

For the loaded dataset latticist attempts to produce useful displays
based on the properties of the data.", tvsep=FALSE)

  resetTextview("ggobi_textview", "GGOBI DATA ANALYSIS

GGobi provides a separate interface to perform highly dynamic and
interactive data visualisation.

Specialist tools include tours, scatterplots, barcharts and
parallel coordinates plots. 

Plots allow points to be identified and linked with
brushing across multiple plots.", tvsep=FALSE)


  
  resetTextview("correlation_textview", "NUMERIC VARIABLE CORRELATION

A correlation analysis will provide insights into how independent
the input variables are.

Modelling often assumes independence, and better models will
result when using independent input variables.

A table of the correlations between each of the numeric variables
will be listed, and a correlation plot will be displayed.", tvsep=FALSE)

  resetTextview("hiercor_textview", "NUMERIC VARIABLE HIERARCHICAL CORRELATION

Dendrograms provide a visual clue to the degree of closeness between variables.

The hierarchical correlation dendrogram produced here presents a view
of the variables of the dataset showing their relationships (correlations).
Depending on the data, you may find groupings of variables that are highly
correlated. These will be fairly obvious in most cases.

The length of the lines in the dendrogram provide a visual indication of
the degree of correlation (or the tightness of the correlation - shorter
lines indicate more tighly correlated variables).

Once you have identified the groups of variables that are correlated,
you may want to reduce the number of variables you are including in your
modelling.

Note that only numeric data is processed to produce the plot. Categoricals
are not handled by this analysis.", tvsep=FALSE)
  
  resetTextview("prcomp_textview", tvsep=FALSE, "PRINCIPAL COMPONENTS ANALYSIS

Principal Components Analysis can provide insights into the importance
of variables in explaining the variation found within the dataset.

Two plots will be displayed. The bar chart shows to significance of
each component, whilst the biplot remaps the data points from their
original coordinates to coordinates of the first two principal
coordinates.")

  resetTextview("test_textview", tvsep=FALSE, "STATISTICAL TESTS

These tests apply to two samples. The paired two sample tests assume
that we have two samples or observations for each entity, and that we
are testing for a change, usually from one time period to another.

DISTRIBUTION OF THE DATA

  Kolomogorov-Smirnov     Non-parametric    Are the distributions the same?
  Wilcoxon Signe Rank     Non-parametric    Do paired samples have the same distribution?

LOCATION OF THE AVERAGE

  T-test               Parametric        Are the means the same?
  Wilcoxon Rank-Sum    Non-parametric    Are the medians the same?

VARIATION IN THE DATA

  F-test    Parametric    Are the variances the same?

CORRELATION

  Correlation    Pearsons    Are the values from the paired samples correlated?")
  
  resetTextview("kmeans_textview")
  resetTextview("hclust_textview")
  resetTextview("associate_textview")
  resetTextview("rpart_textview")
  resetTextview("glm_textview")
  resetTextview("ada_textview")
  resetTextview("rf_textview")
  resetTextview("esvm_textview")
  resetTextview("ksvm_textview")
  resetTextview("nnet_textview")
  resetTextview("confusion_textview")
  resetTextview("risk_textview")
  resetTextview("roc_textview")

  return(TRUE)
}  
